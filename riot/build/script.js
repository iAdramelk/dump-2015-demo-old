var data = {"search":{"action":"#","query":"Всякая фигня"},"menu":{"items":[{"href":"#","text":"Кареты","current":false},{"href":"#","text":"Лошади","current":false},{"href":"#","text":"Кучеры","current":false},{"href":"#","text":"Лакеи","current":false},{"href":"#","text":"Платья","current":true},{"href":"#","text":"Туфли","current":false}]},"breadcrumbs":[{"href":"#","text":"Платья"},{"href":"#","text":"Платья бальные"}],"title":"Коктельные платья","sorting":[{"href":"#","text":"по популярности"},{"href":"#","text":"по цене"},{"href":"#","text":"по новизне"}],"viewMode":[{"href":"#","text":"плиткой"},{"href":"#","text":"списком"}],"goods":[{"image":"../tmp/placeholder-01.jpg","href":"#","title":"Платье Mary Mea","price":2700,"description":"Элегантное коктейльное платье из качественной вискозной ткани, имитирующей кружево. Сочетание тонкого рисунка и романтичных линий платья создают стильный и в тоже время нежный образ. В этом платье Вы будите выглядеть роскошно на любом празднике!"},{"image":"../tmp/placeholder-02.jpg","href":"#","title":"Платье Goddess London","price":4700,"description":"Шик этого платья будет заметен женщине, обладающей отличным вкусом. Прямой крой подчеркнет стройный силуэт фигуры. Вырез горловины достаточно универсален. Рукава длиной в 3/4. Платье застегивается на молнию. Декор в виде рисунка по всему изделию продемонстрирует Вашу богатую натуру. Такое платье уместно как на каждый день, так и в создании коктейльного образа."},{"image":"../tmp/placeholder-03.jpg","href":"#","title":"Платье People","price":1999,"description":"Маленькое коктейльное платье модного расклешенного к низу трапециевидного силуэта выполнено из тонкой плательной ткани. В нижней части платье декорировано широкой кружевной тесьмой в тон основному материалу. Эта эффектная модель отлично скроет небольшие несовершенства фигуры в области талии и бедер, визуально удлинит ноги и сделает силуэт легче и изящнее. Отличный вариант для шумной вечеринки!"},{"image":"../tmp/placeholder-04.jpg","href":"#","title":"Платье BSB","price":2000,"description":"Это интересное платье длины \"мини\" сможет стать Вашим партнером на коктейльной вечеринке и в повседневной носке. Модель с округлым вырезом горловины и короткими рукавами оформлена геометрическим орнаментом."},{"image":"../tmp/placeholder-05.jpg","href":"#","title":"Платье Key","price":2750,"description":"Коктейльное, короткое платье, оформленное изысканными складками и эффектом запаха на лифе. Модель с V-образным вырезом, эффектной яркой расцветки. Восхитительный вариант на жаркий сезон."},{"image":"../tmp/placeholder-06.jpg","href":"#","title":"Платье V&V","price":1700,"description":"Коктейльное платье из качественной полушерстяной ткани, расклешенное от бедер, длиной до колен, без воротника, горловина V-образной формы, без рукавов, без подкладки. Спереди выполнен один горизонтальный рельеф под грудью от левого до правого бокового шва, один наклонный рельеф от левого бокового шва на уровне линии ниже талии до правого бокового шва на уровне бедер."},{"image":"../tmp/placeholder-07.jpg","href":"#","title":"Платье Prio","price":5520,"description":"Вы будете выглядеть великолепно в этом комбинированном коктейльном розовом платье с розочкой. Наряд создан талантливыми мастерами специально для ценительниц моды, комфорта. Платье без рукавов, на широких лямках, декольте треугольное, глубокое. Лиф отрезной, на запахе, яркий акцент сделан на красоте груди. От линии отреза платье спускается ярусами, лёгкими складками. Атлас и шифон одного тона создали шикарный ансамбль, разные фактуры отлично сочетаются. Под лифом удачным аксессуаром стала маленькая нежная..."},{"image":"../tmp/placeholder-08.jpg","href":"#","title":"Платье Fever","price":2320,"description":"Симпатичное, коктейльное короткое платье на изящных бретелях. Приталенный силуэт. Модель оформлена эффектным кружевом."},{"image":"../tmp/placeholder-09.jpg","href":"#","title":"Платье Verezo","price":8700,"description":"Платье-футляр из двух тканей. На горловине и манжетах - легкая сборка, которая придает образу кокетливые нотки. Изделие приталенного силуэта, с застежкой на молнию. Красивый вариант на коктейльное мероприятие."},{"image":"../tmp/placeholder-10.jpg","href":"#","title":"Платье Tops&Tops","price":2190,"description":"Прекрасный вариант для романтического свидания или коктейльной вечеринки - красивое легкое платье. Модель на широких бретелях с застежкой на молнию сзади. Верхний слой выполнен из кружевного полотна расшитого пайетками."},{"image":"../tmp/placeholder-11.jpg","href":"#","title":"Платье Richardi","price":3000,"description":"Прекрасный вариант для романтического свидания или коктейльной вечеринки - красивое легкое платье. Модель на широких бретелях с застежкой на молнию сзади. Верхний слой выполнен из кружевного полотна расшитого пайетками."},{"image":"../tmp/placeholder-12.jpg","href":"#","title":"Платье T&M","price":701,"description":"Эффектное, коктейльное платье с фигурным вырезом на лифе отлично подойдет для создания яркого образа. Модель средней длины, приталенного силуэта с расклешенной юбочной частью, помогает в выгодном свете подчеркнуть все ее достоинства, а в сочетании с высокими каблуками выглядит сексуально и приковывает восхищенные взгляды."}],"banners":[{"href":"#","text":"Лучшие мыши на рынке! Оптом дешевле!"},{"href":"#","text":"Лучшие тараканы!"},{"href":"#","text":"А туфли у нас вообще отпад!"}],"categories":[{"level":"1","href":"#","text":"Платья","current":false},{"level":"2","href":"#","text":"Платья бальные","current":false},{"level":"3","href":"#","text":"Коктельные платья","current":true},{"level":"3","href":"#","text":"Клубные платья","current":false},{"level":"3","href":"#","text":"Вечерние платья","current":false},{"level":"3","href":"#","text":"Выпускные платья","current":false}],"facets":[{"title":"Цена, руб.","closed":false,"content":{"min":900,"max":20000,"from":"","to":""}},{"title":"Основной материал","closed":false,"content":{"items":[{"href":"#","text":"Акрил","selected":false},{"href":"#","text":"Вискоза","selected":true},{"href":"#","text":"Лайкра","selected":false},{"href":"#","text":"Лен","selected":true},{"href":"#","text":"Клен","selected":false}],"limit":4}},{"title":"Размер","closed":false,"content":{"compact":true,"items":[{"href":"#","text":"38","selected":false},{"href":"#","text":"39","selected":false},{"href":"#","text":"40","selected":false},{"href":"#","text":"41","selected":false},{"href":"#","text":"42","selected":false},{"href":"#","text":"43","selected":false},{"href":"#","text":"44","selected":false},{"href":"#","text":"45","selected":false}]}}],"help":{"title":"Полезные ссылки","items":[{"href":"#","text":"Доставка"},{"href":"#","text":"Оплата"},{"href":"#","text":"Бесплатная примерка"},{"href":"#","text":"Возврат"}]},"article":{"href":"#","title":"Платья бальные","lead":"Несмотря на то, что времена рыцарей и помпезных балов давно прошли, бальные платья все также пользуются спросом в нашем стремительно развивающемся мире.","text":"Каждая девушка с детства мечтает оказаться на настоящем балу, почувствовать себя принцессой в восхитительном пышном платье, приковывающем к ней все внимание. Исполнить эту мечту вполне реально, ведь в нашей жизни еще случаются разнообразные балы! Быть может вас ожидает выпускной, свадебный, студенческий или новогодний бал, вы занимаетесь бальными танцами, участвуете в конкурсе красоты или даже приглашены на «венский бал»? В любом случае вам понадобится шикарное бальное платье.<br/><br/>Бальные платья – это необычайно роскошные платья с пышной длинной юбкой на кринолине до самого пола. Они выполняются из дорогих красивых тканей и украшаются изысканной отделкой: кружевами, драпировками, блестками, бисером, стразами, жемчугом, рюшами, вышивкой и другими декоративными элементами. Фасон и силуэт бального платья может быть достаточно разнообразным от пышного до свободного в стиле ампир. Форма рукавов, юбки, корсета и декольте может отличаться. Многое зависит от предпочтений девушки и выбранной эпохи бала. В любом случае такой наряд позволит вам почувствовать себя настоящей королевой – женственной, стильной, интригующей и неотразимой.<br/><br/>Надевая бальное платье каждая женщина буквально преображается. Передать словами то волнение и чувства, которые она испытывает в данный момент, практически невозможно. Легкое и воздушное, словно облако, и по неземному красивое платье переносит свою хозяйку в настоящую сказку. Каким бы ни был повод надеть бальное платье, этот момент навсегда останется в вашей памяти.<br/><br/>Покупка бального платья – дорогостоящее удовольствие. Ведь на создание таких нарядов уходят десятки, а то и сотни метров роскошных тканей: атласа, кружева, гипюра, органзы, шелка, бархата, парчи, тафты и т.д. Кроме того, их создание предполагает сложную ручную отделку. Чтобы снизить расходы многие предпочитают шить бальные платья на заказ. Здесь есть свои плюсы – платье точно будет уникальным, а также будет идеально сидеть на фигуре. А если вы не хотите покупать платье на один раз, можно взять его на прокат.<br/><br/>Главное в любом бальном платье – это акцент на женственной фигуре. Они должны подчеркивать тонкую талию, красивую грудь, нежную шею и плечи. Поэтому платья обычно шьются с использованием корсета и имеют открытые плечи и декольте. Длинные пышные юбки создают эффект воздушности и роскоши.<br/><br/>Для создания платьев обычно используют тафту, бархат, шелк, шифон, атлас, кружево или гипюр. Они украшаются драпировками, вышивками или дополняются легкими прозрачными элементами из органзы, тюля, газа. Также они могут украшаться мехом, перьями, искусственными или живыми цветами.<br/><br/>Они прекрасно подходят как юным девушкам, так и взрослым женщинам. Очень интересно выглядят бальные платья благородных насыщенных оттенков: бордового, синего, изумрудного, фиолетового, красного цвета."}};

/* Riot v2.0.13, @license MIT, (c) 2015 Muut Inc. + contributors */

;(function() {

  var riot = { version: 'v2.0.13', settings: {} }

  'use strict'

riot.observable = function(el) {

  el = el || {}

  var callbacks = {},
      _id = 0

  el.on = function(events, fn) {
    if (typeof fn == 'function') {
      fn._id = typeof fn._id == 'undefined' ? _id++ : fn._id

      events.replace(/\S+/g, function(name, pos) {
        (callbacks[name] = callbacks[name] || []).push(fn)
        fn.typed = pos > 0
      })
    }
    return el
  }

  el.off = function(events, fn) {
    if (events == '*') callbacks = {}
    else {
      events.replace(/\S+/g, function(name) {
        if (fn) {
          var arr = callbacks[name]
          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {
            if (cb._id == fn._id) { arr.splice(i, 1); i-- }
          }
        } else {
          callbacks[name] = []
        }
      })
    }
    return el
  }

  // only single event supported
  el.one = function(name, fn) {
    if (fn) fn.one = 1
    return el.on(name, fn)
  }

  el.trigger = function(name) {
    var args = [].slice.call(arguments, 1),
        fns = callbacks[name] || []

    for (var i = 0, fn; (fn = fns[i]); ++i) {
      if (!fn.busy) {
        fn.busy = 1
        fn.apply(el, fn.typed ? [name].concat(args) : args)
        if (fn.one) { fns.splice(i, 1); i-- }
         else if (fns[i] !== fn) { i-- } // Makes self-removal possible during iteration
        fn.busy = 0
      }
    }

    if (callbacks.all && name != 'all') {
      el.trigger.apply(el, ['all', name].concat(args))
    }

    return el
  }

  return el

}
;(function(riot, evt) {

  // browsers only
  if (!this.top) return

  var loc = location,
      fns = riot.observable(),
      win = window,
      current

  function hash() {
    return loc.href.split('#')[1] || ''
  }

  function parser(path) {
    return path.split('/')
  }

  function emit(path) {
    if (path.type) path = hash()

    if (path != current) {
      fns.trigger.apply(null, ['H'].concat(parser(path)))
      current = path
    }
  }

  var r = riot.route = function(arg) {
    // string
    if (arg[0]) {
      loc.hash = arg
      emit(arg)

    // function
    } else {
      fns.on('H', arg)
    }
  }

  r.exec = function(fn) {
    fn.apply(null, parser(hash()))
  }

  r.parser = function(fn) {
    parser = fn
  }

  win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)

})(riot, 'hashchange')
/*

//// How it works?


Three ways:

1. Expressions: tmpl('{ value }', data).
   Returns the result of evaluated expression as a raw object.

2. Templates: tmpl('Hi { name } { surname }', data).
   Returns a string with evaluated expressions.

3. Filters: tmpl('{ show: !done, highlight: active }', data).
   Returns a space separated list of trueish keys (mainly
   used for setting html classes), e.g. "show highlight".


// Template examples

tmpl('{ title || "Untitled" }', data)
tmpl('Results are { results ? "ready" : "loading" }', data)
tmpl('Today is { new Date() }', data)
tmpl('{ message.length > 140 && "Message is too long" }', data)
tmpl('This item got { Math.round(rating) } stars', data)
tmpl('<h1>{ title }</h1>{ body }', data)


// Falsy expressions in templates

In templates (as opposed to single expressions) all falsy values
except zero (undefined/null/false) will default to empty string:

tmpl('{ undefined } - { false } - { null } - { 0 }', {})
// will return: " - - - 0"

*/


var brackets = (function(orig, s, b) {
  return function(x) {

    // make sure we use the current setting
    s = riot.settings.brackets || orig
    if (b != s) b = s.split(' ')

    // if regexp given, rewrite it with current brackets (only if differ from default)
    return x && x.test
      ? s == orig
        ? x : RegExp(x.source
                      .replace(/\{/g, b[0].replace(/(?=.)/g, '\\'))
                      .replace(/\}/g, b[1].replace(/(?=.)/g, '\\')),
                    x.global ? 'g' : '')

      // else, get specific bracket
      : b[x]

  }
})('{ }')


var tmpl = (function() {

  var cache = {},
      re_vars = /(['"\/]).*?[^\\]\1|\.\w*|\w*:|\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\b|function *\()|([a-z_$]\w*)/gi
              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]
              // find variable names:
              // 1. skip quoted strings and regexps: "a b", 'a b', 'a \'b\'', /a b/
              // 2. skip object properties: .name
              // 3. skip object literals: name:
              // 4. skip javascript keywords
              // 5. match var name

  // build a template (or get it from cache), render with data
  return function(str, data) {
    return str && (cache[str] = cache[str] || tmpl(str))(data)
  }


  // create a template instance

  function tmpl(s, p) {

    // default template string to {}
    s = (s || (brackets(0) + brackets(1)))

      // temporarily convert \{ and \} to a non-character
      .replace(brackets(/\\{/g), '\uFFF0')
      .replace(brackets(/\\}/g), '\uFFF1')

    // split string to expression and non-expresion parts
    p = split(s, extract(s, brackets(/{/), brackets(/}/)))

    return new Function('d', 'return ' + (

      // is it a single expression or a template? i.e. {x} or <b>{x}</b>
      !p[0] && !p[2] && !p[3]

        // if expression, evaluate it
        ? expr(p[1])

        // if template, evaluate all expressions in it
        : '[' + p.map(function(s, i) {

            // is it an expression or a string (every second part is an expression)
          return i % 2

              // evaluate the expressions
              ? expr(s, true)

              // process string parts of the template:
              : '"' + s

                  // preserve new lines
                  .replace(/\n/g, '\\n')

                  // escape quotes
                  .replace(/"/g, '\\"')

                + '"'

        }).join(',') + '].join("")'
      )

      // bring escaped { and } back
      .replace(/\uFFF0/g, brackets(0))
      .replace(/\uFFF1/g, brackets(1))

    + ';')

  }


  // parse { ... } expression

  function expr(s, n) {
    s = s

      // convert new lines to spaces
      .replace(/\n/g, ' ')

      // trim whitespace, brackets, strip comments
      .replace(brackets(/^[{ ]+|[ }]+$|\/\*.+?\*\//g), '')

    // is it an object literal? i.e. { key : value }
    return /^\s*[\w- "']+ *:/.test(s)

      // if object literal, return trueish keys
      // e.g.: { show: isOpen(), done: item.done } -> "show done"
      ? '[' +

          // extract key:val pairs, ignoring any nested objects
          extract(s,

              // name part: name:, "name":, 'name':, name :
              /["' ]*[\w- ]+["' ]*:/,

              // expression part: everything upto a comma followed by a name (see above) or end of line
              /,(?=["' ]*[\w- ]+["' ]*:)|}|$/
              ).map(function(pair) {

                // get key, val parts
                return pair.replace(/^[ "']*(.+?)[ "']*: *(.+?),? *$/, function(_, k, v) {

                  // wrap all conditional parts to ignore errors
                  return v.replace(/[^&|=!><]+/g, wrap) + '?"' + k + '":"",'

                })

              }).join('')

        + '].join(" ").trim()'

      // if js expression, evaluate as javascript
      : wrap(s, n)

  }


  // execute js w/o breaking on errors or undefined vars

  function wrap(s, nonull) {
    s = s.trim()
    return !s ? '' : '(function(v){try{v='

        // prefix vars (name => data.name)
        + (s.replace(re_vars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })

          // break the expression if its empty (resulting in undefined value)
          || 'x')

      + '}finally{return '

        // default to empty string for falsy values except zero
        + (nonull === true ? '!v&&v!==0?"":v' : 'v')

      + '}}).call(d)'
  }


  // split string by an array of substrings

  function split(str, substrings) {
    var parts = []
    substrings.map(function(sub, i) {

      // push matched expression and part before it
      i = str.indexOf(sub)
      parts.push(str.slice(0, i), sub)
      str = str.slice(i + sub.length)
    })

    // push the remaining part
    return parts.concat(str)
  }


  // match strings between opening and closing regexp, skipping any inner/nested matches

  function extract(str, open, close) {

    var start,
        level = 0,
        matches = [],
        re = new RegExp('('+open.source+')|('+close.source+')', 'g')

    str.replace(re, function(_, open, close, pos) {

      // if outer inner bracket, mark position
      if(!level && open) start = pos

      // in(de)crease bracket level
      level += open ? 1 : -1

      // if outer closing bracket, grab the match
      if(!level && close != null) matches.push(str.slice(start, pos+close.length))

    })

    return matches
  }

})()

// { key, i in items} -> { key, i, items }
function loopKeys(expr) {
  var ret = { val: expr },
      els = expr.split(/\s+in\s+/)

  if (els[1]) {
    ret.val = brackets(0) + els[1]
    els = els[0].slice(brackets(0).length).trim().split(/,\s*/)
    ret.key = els[0]
    ret.pos = els[1]
  }

  return ret
}

function mkitem(expr, key, val) {
  var item = {}
  item[expr.key] = key
  if (expr.pos) item[expr.pos] = val
  return item
}


/* Beware: heavy stuff */
function _each(dom, parent, expr) {

  remAttr(dom, 'each')

  var template = dom.outerHTML,
      prev = dom.previousSibling,
      root = dom.parentNode,
      rendered = [],
      tags = [],
      checksum

  expr = loopKeys(expr)

  function add(pos, item, tag) {
    rendered.splice(pos, 0, item)
    tags.splice(pos, 0, tag)
  }

  // clean template code
  parent.one('update', function() {
    root.removeChild(dom)

  }).one('premount', function() {
    if (root.stub) root = parent.root

  }).on('update', function() {

    var items = tmpl(expr.val, parent)
    if (!items) return

    // object loop. any changes cause full redraw
    if (!Array.isArray(items)) {
      var testsum = JSON.stringify(items)
      if (testsum == checksum) return
      checksum = testsum

      // clear old items
      each(tags, function(tag) { tag.unmount() })
      rendered = []
      tags = []

      items = Object.keys(items).map(function(key) {
        return mkitem(expr, key, items[key])
      })

    }

    // unmount redundant
    each(rendered, function(item) {
      if (item instanceof Object) {
        // skip existing items
        if (items.indexOf(item) > -1) {
          return
        }
      } else {
        // find all non-objects
        var newItems = arrFindEquals(items, item),
            oldItems = arrFindEquals(rendered, item)

        // if more or equal amount, no need to remove
        if (newItems.length >= oldItems.length) {
          return
        }
      }
      var pos = rendered.indexOf(item),
          tag = tags[pos]

      if (tag) {
        tag.unmount()
        rendered.splice(pos, 1)
        tags.splice(pos, 1)
      }

    })

    // mount new / reorder
    var nodes = [].slice.call(root.childNodes),
        prev_index = nodes.indexOf(prev)

    each(items, function(item, i) {

      // start index search from position based on the current i
      var pos = items.indexOf(item, i),
          oldPos = rendered.indexOf(item, i)

      // if not found, search backwards from current i position
      pos < 0 && (pos = items.lastIndexOf(item, i))
      oldPos < 0 && (oldPos = rendered.lastIndexOf(item, i))

      if (!(item instanceof Object)) {
        // find all non-objects
        var newItems = arrFindEquals(items, item),
            oldItems = arrFindEquals(rendered, item)

        // if more, should mount one new
        if (newItems.length > oldItems.length) {
          oldPos = -1
        }
      }

      // mount new
      if (oldPos < 0) {
        rendered.push(item)
        if (!checksum && expr.key) item = mkitem(expr, item, pos)

        var tag = new Tag({ tmpl: template }, {
          before: nodes[prev_index + 1 + pos],
          parent: parent,
          root: root,
          item: item
        })

        tag.mount()

        return add(pos, item, tag)
      }

      // change pos value
      if (expr.pos && tags[oldPos][expr.pos] != pos) {
        tags[oldPos].one('update', function(item) {
          item[expr.pos] = pos
        })
        tags[oldPos].update()
      }

      // reorder
      if (pos != oldPos) {
        root.insertBefore(nodes[prev_index + oldPos + 1], nodes[prev_index + pos + 1])
        return add(pos, rendered.splice(oldPos, 1)[0], tags.splice(oldPos, 1)[0])
      }

    })

    rendered = items.slice()

  })

}


function parseNamedElements(root, parent, child_tags) {

  walk(root, function(dom) {
    if (dom.nodeType == 1) {

      // custom child tag
      var child = getTag(dom)

      if (child && !dom.getAttribute('each')) {
        var tag = new Tag(child, { root: dom, parent: parent })
        parent.tags[dom.getAttribute('name') || child.name] = tag
        // empty the child node once we got its template
        // to avoid that its children get compiled multiple times
        dom.innerHTML = ''
        child_tags.push(tag)
      }

      each(dom.attributes, function(attr) {
        if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom
      })
    }

  })

}

function parseExpressions(root, tag, expressions) {

  function addExpr(dom, val, extra) {
    if (val.indexOf(brackets(0)) >= 0) {
      var expr = { dom: dom, expr: val }
      expressions.push(extend(expr, extra))
    }
  }

  walk(root, function(dom) {
    var type = dom.nodeType

    // text node
    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)
    if (type != 1) return

    /* element */

    // loop
    var attr = dom.getAttribute('each')
    if (attr) { _each(dom, tag, attr); return false }

    // attribute expressions
    each(dom.attributes, function(attr) {
      var name = attr.name,
          bool = name.split('__')[1]

      addExpr(dom, attr.value, { attr: bool || name, bool: bool })
      if (bool) { remAttr(dom, name); return false }

    })

    // skip custom tags
    if (getTag(dom)) return false

  })

}

function Tag(impl, conf) {

  var self = riot.observable(this),
      opts = inherit(conf.opts) || {},
      dom = mkdom(impl.tmpl),
      parent = conf.parent,
      expressions = [],
      child_tags = [],
      root = conf.root,
      item = conf.item,
      fn = impl.fn,
      attr = {},
      loop_dom

  if (fn && root.riot) return
  root.riot = true

  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)

  // grab attributes
  each(root.attributes, function(el) {
    attr[el.name] = el.value
  })

  // options
  function updateOpts(rem_attr) {
    each(Object.keys(attr), function(name) {
      opts[name] = tmpl(attr[name], parent || self)
    })
  }

  this.update = function(data, init) {
    extend(self, data, item)
    updateOpts()
    self.trigger('update', item)
    update(expressions, self, item)
    self.trigger('updated')
  }

  this.mount = function() {

    updateOpts()

    // initialiation
    fn && fn.call(self, opts)

    toggle(true)

    // parse layout after init. fn may calculate args for nested custom tags
    parseExpressions(dom, self, expressions)

    self.update()

    // internal use only, fixes #403
    self.trigger('premount')

    if (fn) {
      while (dom.firstChild) root.appendChild(dom.firstChild)

    } else {
      loop_dom = dom.firstChild
      root.insertBefore(loop_dom, conf.before || null) // null needed for IE8
    }

    if (root.stub) self.root = root = parent.root
    self.trigger('mount')

  }


  this.unmount = function() {
    var el = fn ? root : loop_dom,
        p = el.parentNode

    if (p) {
      if (parent) p.removeChild(el)
      else while (root.firstChild) root.removeChild(root.firstChild)
      toggle()
      self.trigger('unmount')
      self.off('*')
      delete root.riot
    }

  }

  function toggle(is_mount) {

    // mount/unmount children
    each(child_tags, function(child) { child[is_mount ? 'mount' : 'unmount']() })

    // listen/unlisten parent (events flow one way from parent to children)
    if (parent) {
      var evt = is_mount ? 'on' : 'off'
      parent[evt]('update', self.update)[evt]('unmount', self.unmount)
    }
  }

  // named elements available for fn
  parseNamedElements(dom, this, child_tags)


}

function setEventHandler(name, handler, dom, tag, item) {

  dom[name] = function(e) {

    // cross browser event fix
    e = e || window.event
    e.which = e.which || e.charCode || e.keyCode
    e.target = e.target || e.srcElement
    e.currentTarget = dom
    e.item = item

    // prevent default behaviour (by default)
    if (handler.call(tag, e) !== true) {
      e.preventDefault && e.preventDefault()
      e.returnValue = false
    }

    var el = item ? tag.parent : tag
    el.update()

  }

}

// used by if- attribute
function insertTo(root, node, before) {
  if (root) {
    root.insertBefore(before, node)
    root.removeChild(node)
  }
}

// item = currently looped item
function update(expressions, tag, item) {

  each(expressions, function(expr) {

    var dom = expr.dom,
        attr_name = expr.attr,
        value = tmpl(expr.expr, tag),
        parent = expr.dom.parentNode

    if (value == null) value = ''

    // leave out riot- prefixes from strings inside textarea
    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')

    // no change
    if (expr.value === value) return
    expr.value = value

    // text node
    if (!attr_name) return dom.nodeValue = value

    // remove original attribute
    remAttr(dom, attr_name)

    // event handler
    if (typeof value == 'function') {
      setEventHandler(attr_name, value, dom, tag, item)

    // if- conditional
    } else if (attr_name == 'if') {
      var stub = expr.stub

      // add to DOM
      if (value) {
        stub && insertTo(stub.parentNode, stub, dom)

      // remove from DOM
      } else {
        stub = expr.stub = stub || document.createTextNode('')
        insertTo(dom.parentNode, dom, stub)
      }

    // show / hide
    } else if (/^(show|hide)$/.test(attr_name)) {
      if (attr_name == 'hide') value = !value
      dom.style.display = value ? '' : 'none'

    // field value
    } else if (attr_name == 'value') {
      dom.value = value

    // <img src="{ expr }">
    } else if (attr_name.slice(0, 5) == 'riot-') {
      attr_name = attr_name.slice(5)
      value ? dom.setAttribute(attr_name, value) : remAttr(dom, attr_name)

    } else {
      if (expr.bool) {
        dom[attr_name] = value
        if (!value) return
        value = attr_name
      }

      if (typeof value != 'object') dom.setAttribute(attr_name, value)

    }

  })

}
function each(els, fn) {
  for (var i = 0, len = (els || []).length, el; i < len; i++) {
    el = els[i]
    // return false -> reomve current item during loop
    if (el != null && fn(el, i) === false) i--
  }
  return els
}

function remAttr(dom, name) {
  dom.removeAttribute(name)
}

// max 2 from objects allowed
function extend(obj, from, from2) {
  from && each(Object.keys(from), function(key) {
    obj[key] = from[key]
  })
  return from2 ? extend(obj, from2) : obj
}

function mkdom(template) {
  var tag_name = template.trim().slice(1, 3).toLowerCase(),
      root_tag = /td|th/.test(tag_name) ? 'tr' : tag_name == 'tr' ? 'tbody' : 'div',
      el = document.createElement(root_tag)

  el.stub = true
  el.innerHTML = template
  return el
}

function walk(dom, fn) {
  if (dom) {
    if (fn(dom) === false) walk(dom.nextSibling, fn)
    else {
      dom = dom.firstChild

      while (dom) {
        walk(dom, fn)
        dom = dom.nextSibling
      }
    }
  }
}

function arrDiff(arr1, arr2) {
  return arr1.filter(function(el) {
    return arr2.indexOf(el) < 0
  })
}

function arrFindEquals(arr, el) {
  return arr.filter(function (_el) {
    return _el === el
  })
}

function inherit(parent) {
  function Child() {}
  Child.prototype = parent
  return new Child()
}

/*
 Virtual dom is an array of custom tags on the document.
 Updates and unmounts propagate downwards from parent to children.
*/

var virtual_dom = [],
    tag_impl = {}


function getTag(dom) {
  return tag_impl[dom.tagName.toLowerCase()]
}

function injectStyle(css) {
  var node = document.createElement('style')
  node.innerHTML = css
  document.head.appendChild(node)
}

function mountTo(root, tagName, opts) {
  var tag = tag_impl[tagName]

  if (tag && root) tag = new Tag(tag, { root: root, opts: opts })

  if (tag && tag.mount) {
    tag.mount()
    virtual_dom.push(tag)
    return tag.on('unmount', function() {
      virtual_dom.splice(virtual_dom.indexOf(tag), 1)
    })
  }

}

riot.tag = function(name, html, css, fn) {
  if (typeof css == 'function') fn = css
  else if (css) injectStyle(css)
  tag_impl[name] = { name: name, tmpl: html, fn: fn }
}

riot.mount = function(selector, tagName, opts) {
  if (selector == '*') selector = Object.keys(tag_impl).join(', ')
  if (typeof tagName == 'object') { opts = tagName; tagName = 0 }

  var tags = []

  function push(root) {
    var name = tagName || root.tagName.toLowerCase(),
        tag = mountTo(root, name, opts)

    if (tag) tags.push(tag)
  }

  // DOM node
  if (selector.tagName) {
    push(selector)
    return tags[0]

  // selector
  } else {
    each(document.querySelectorAll(selector), push)
    return tags
  }

}

// update everything
riot.update = function() {
  return each(virtual_dom, function(tag) {
    tag.update()
  })
}

// @deprecated
riot.mountTo = riot.mount


  
  // share methods for other riot parts, e.g. compiler
  riot.util = { brackets: brackets, tmpl: tmpl }

  // support CommonJS
  if (typeof exports === 'object')
    module.exports = riot

  // support AMD
  else if (typeof define === 'function' && define.amd)
    define(function() { return riot })

  // support browser
  else
    this.riot = riot

})();

riot.tag('x-article', '<div class="article"> <raw content="{opts.text}"> </div>', function(opts) {

});

riot.tag('x-article-lead', '<div className="article-lead"> {opts.text} <a href="{opts.href}" className="article-lead__link">Читать далее →</a> </div>', function(opts) {

});

riot.tag('x-banner', '<div class="banner{opts.grid ? \' banner_grid\' : \'\'}"> <a href="{opts.href}" class="banner__link">{opts.text}</a> </div>', function(opts) {

});

riot.tag('x-breadcrumbs', '<div class="breadcrumbs"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-breadcrumbs-item', '<div class="breadcrumbs__item"> <a href="{opts.href}" class="breadcrumbs__link">{opts.text}</a> </div>', function(opts) {

});

riot.tag('x-categories', '<div class="categories"> <div class="categories__title">Категории</div> <div each="{opts.items}" class="categories__item categories__item_level_{level}"> <a href="{href}" class="categories__link{current ? \' is-current\' : \'\'}">{text}</a> </div> </div>', function(opts) {

});

riot.tag('x-checkbox-list', '<div class="checkbox-list{opts.compact ? \' is-compact\' : \'\'}"> <div class="checkbox-list__list"> <div class="checkbox-list__item" each="{items}"> <a href="{href}" class="checkbox-list__link{selected ? \' is-selected\' : \'\'}"> {text} </a> </div> </div> <div class="checkbox-list__more" if="{counter > 0}">{"Еще " + counter + "…"}</div> </div>', function(opts) {

  this.shown   = this.opts.limit ? this.opts.limit : this.opts.items.length;
  this.items   = this.opts.items.slice(0, this.shown);
  this.counter = this.opts.items.length - this.opts.limit;

});

riot.tag('x-content', '<div class="content"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-facet', '<div class="facet{opts.closed ? \' is-closed\' : \'\'}"> <div class="facet__title">{opts.title}</div> <div class="facet__content"> <inner-html></inner-html> </div> </div>', function(opts) {

});

riot.tag('x-facets', '<div class="facets"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-footer', '<div class="footer">© 2013-2015 Общество Фей</div>', function(opts) {

});

riot.tag('x-header', '<div class="header"> <div class="header__subtitle">интернет-магазин одежды</div> <div class="header__actions"> <div class="header__action header__action_signin"> <a href="#" class="header__link">Войти</a> </div> <div class="header__action header__action_signup"> <a href="#" class="header__link">Зарегистрироваться</a> </div> <div class="header__action header__action_basket"> <a href="#" class="header__link">Корзина</a> </div> </div> <div class="header__title">Золушка</div> <div class="header__search"> <inner-html></inner-html> </div> </div>', function(opts) {

});

riot.tag('x-help', '<div class="help"> <div class="help__title">{opts.title}</div> <div each="{opts.items}" class="help__item"> <a href="{href}" class="help__link">{text}</a> </div> </div>', function(opts) {

});

riot.tag('inner-html', '', function(opts) {
  var p = this.parent.root
  while (p.firstChild) this.root.appendChild(p.firstChild)

});

riot.tag('x-list-item', '<div class="list-item"> <a href="{opts.href}"><img riot-src="{opts.image}" class="list-item__image"></a> <div class="list-item__meta"> <div class="list-item__price">{formattedPrice}</div> <div class="list-item__title"><a href="{opts.href}">{opts.title}</a></div> <div class="list-item__description"> {opts.description} </div> </div> </div>', function(opts) {

  this.formattedPrice = this.opts.price.toLocaleString("ru-RU", {style: "currency", currency: "RUB", minimumFractionDigits: 0});

});

riot.tag('x-listing', '<div class="listing"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-header', '<div class="listing__header"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-breadcrumbs', '<div class="listing__breadcrumbs"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-title', '<h1 class="listing__title">{opts.title}</h1>', function(opts) {

});

riot.tag('x-listing-sorting', '<div class="listing__sorting"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-view-mode', '<div class="listing__view-mode"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-content', '<div class="listing__content"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-main', '<div class="listing__main{opts.advanced ? \' listing__main_advanced-items\' : \'\'}"> <inner-html></inner-html> </div>', function(opts) {

  console.log(this.opts.advanced)

});

riot.tag('x-listing-nav', '<div class="listing__nav"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-menu', '<div class="menu"> <div class="menu__content"> <div each="{opts.items}" class="menu__item"> <a href="{href}" class="menu__link{current ? \' is-current\' : \'\'}">{text}</a> </div> </div> </div>', function(opts) {

});

riot.tag('x-page', '<div class="page"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-preview-item', '<div class="preview-item"> <a href="{opts.href}" class="preview-item__link"> <img riot-src="{opts.image}" class="preview-item__image"> <div class="preview-item__meta"> <div class="preview-item__title">{opts.title}</div> <div class="preview-item__price">{formattedPrice}</div> </div> </a> </div>', function(opts) {

  this.formattedPrice = this.opts.price.toLocaleString("ru-RU", {style: "currency", currency: "RUB", minimumFractionDigits: 0});

});

riot.tag('x-price', '<div class="price"> <div class="price__range"> <div class="price__group price__group_from"> <label class="price__title">От:</label> <input type="text" class="price__field" placeholder="{opts.min}" value="{opts.from}"> </div> <div class="price__group price__group_to"> <label class="price__title">До:</label> <input type="text" class="price__field" placeholder="{opts.max}" value="{opts.to}"> </div> </div> <div class="price__show">Показать</div> </div>', function(opts) {

});

riot.tag('raw', '<span></span>', function(opts) {

  this.root.innerHTML = opts.content;

});

riot.tag('x-search', '<form action=" {opts.action}" class="search"> <input type="search" placeholder="платье бальное" class="search__query" value=" {opts.value}"> <input type="submit" value="Найти" class="search__submit"> </form>', function(opts) {

  var parent = this.parent;

});

riot.tag('x-sorting', '<div class="sorting"> <div class="sorting__title">Сортировать:</div> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-sorting-item', '<div class="sorting__item"> <a href="{opts.href}" class="sorting__link{opts.current ? \' is-current\' : \'\'}">{opts.text}</a> </div>', function(opts) {

});

riot.tag('x-view-mode', '<div class="view-mode"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-view-mode-item', '<div class="view-mode__item"> <a href="{opts.href}" class="view-mode__link{opts.current ? \' is-current\' : \'\'}">{opts.text}</a> </div>', function(opts) {

});
