var data = {"search":{"action":"#","query":"Всякая фигня"},"menu":{"items":[{"href":"#","text":"Кареты","current":false},{"href":"#","text":"Лошади","current":false},{"href":"#","text":"Кучеры","current":false},{"href":"#","text":"Лакеи","current":false},{"href":"#","text":"Платья","current":true},{"href":"#","text":"Туфли","current":false}]},"breadcrumbs":[{"href":"#","text":"Платья"},{"href":"#","text":"Платья бальные"}],"title":"Коктельные платья","sorting":[{"href":"#","text":"по популярности"},{"href":"#","text":"по цене"},{"href":"#","text":"по новизне"}],"viewMode":[{"href":"#","text":"плиткой"},{"href":"#","text":"списком"}],"goods":[{"image":"../tmp/placeholder-01.jpg","href":"#","title":"Платье Mary Mea","price":2700,"description":"Элегантное коктейльное платье из качественной вискозной ткани, имитирующей кружево. Сочетание тонкого рисунка и романтичных линий платья создают стильный и в тоже время нежный образ. В этом платье Вы будите выглядеть роскошно на любом празднике!"},{"image":"../tmp/placeholder-02.jpg","href":"#","title":"Платье Goddess London","price":4700,"description":"Шик этого платья будет заметен женщине, обладающей отличным вкусом. Прямой крой подчеркнет стройный силуэт фигуры. Вырез горловины достаточно универсален. Рукава длиной в 3/4. Платье застегивается на молнию. Декор в виде рисунка по всему изделию продемонстрирует Вашу богатую натуру. Такое платье уместно как на каждый день, так и в создании коктейльного образа."},{"image":"../tmp/placeholder-03.jpg","href":"#","title":"Платье People","price":1999,"description":"Маленькое коктейльное платье модного расклешенного к низу трапециевидного силуэта выполнено из тонкой плательной ткани. В нижней части платье декорировано широкой кружевной тесьмой в тон основному материалу. Эта эффектная модель отлично скроет небольшие несовершенства фигуры в области талии и бедер, визуально удлинит ноги и сделает силуэт легче и изящнее. Отличный вариант для шумной вечеринки!"},{"image":"../tmp/placeholder-04.jpg","href":"#","title":"Платье BSB","price":2000,"description":"Это интересное платье длины \"мини\" сможет стать Вашим партнером на коктейльной вечеринке и в повседневной носке. Модель с округлым вырезом горловины и короткими рукавами оформлена геометрическим орнаментом."},{"image":"../tmp/placeholder-05.jpg","href":"#","title":"Платье Key","price":2750,"description":"Коктейльное, короткое платье, оформленное изысканными складками и эффектом запаха на лифе. Модель с V-образным вырезом, эффектной яркой расцветки. Восхитительный вариант на жаркий сезон."},{"image":"../tmp/placeholder-06.jpg","href":"#","title":"Платье V&V","price":1700,"description":"Коктейльное платье из качественной полушерстяной ткани, расклешенное от бедер, длиной до колен, без воротника, горловина V-образной формы, без рукавов, без подкладки. Спереди выполнен один горизонтальный рельеф под грудью от левого до правого бокового шва, один наклонный рельеф от левого бокового шва на уровне линии ниже талии до правого бокового шва на уровне бедер."},{"image":"../tmp/placeholder-07.jpg","href":"#","title":"Платье Prio","price":5520,"description":"Вы будете выглядеть великолепно в этом комбинированном коктейльном розовом платье с розочкой. Наряд создан талантливыми мастерами специально для ценительниц моды, комфорта. Платье без рукавов, на широких лямках, декольте треугольное, глубокое. Лиф отрезной, на запахе, яркий акцент сделан на красоте груди. От линии отреза платье спускается ярусами, лёгкими складками. Атлас и шифон одного тона создали шикарный ансамбль, разные фактуры отлично сочетаются. Под лифом удачным аксессуаром стала маленькая нежная..."},{"image":"../tmp/placeholder-08.jpg","href":"#","title":"Платье Fever","price":2320,"description":"Симпатичное, коктейльное короткое платье на изящных бретелях. Приталенный силуэт. Модель оформлена эффектным кружевом."},{"image":"../tmp/placeholder-09.jpg","href":"#","title":"Платье Verezo","price":8700,"description":"Платье-футляр из двух тканей. На горловине и манжетах - легкая сборка, которая придает образу кокетливые нотки. Изделие приталенного силуэта, с застежкой на молнию. Красивый вариант на коктейльное мероприятие."},{"image":"../tmp/placeholder-10.jpg","href":"#","title":"Платье Tops&Tops","price":2190,"description":"Прекрасный вариант для романтического свидания или коктейльной вечеринки - красивое легкое платье. Модель на широких бретелях с застежкой на молнию сзади. Верхний слой выполнен из кружевного полотна расшитого пайетками."},{"image":"../tmp/placeholder-11.jpg","href":"#","title":"Платье Richardi","price":3000,"description":"Прекрасный вариант для романтического свидания или коктейльной вечеринки - красивое легкое платье. Модель на широких бретелях с застежкой на молнию сзади. Верхний слой выполнен из кружевного полотна расшитого пайетками."},{"image":"../tmp/placeholder-12.jpg","href":"#","title":"Платье T&M","price":701,"description":"Эффектное, коктейльное платье с фигурным вырезом на лифе отлично подойдет для создания яркого образа. Модель средней длины, приталенного силуэта с расклешенной юбочной частью, помогает в выгодном свете подчеркнуть все ее достоинства, а в сочетании с высокими каблуками выглядит сексуально и приковывает восхищенные взгляды."}],"categories":[{"level":"1","href":"#","text":"Платья","current":false},{"level":"2","href":"#","text":"Платья бальные","current":false},{"level":"3","href":"#","text":"Коктельные платья","current":true},{"level":"3","href":"#","text":"Клубные платья","current":false},{"level":"3","href":"#","text":"Вечерние платья","current":false},{"level":"3","href":"#","text":"Выпускные платья","current":false}],"facets":[{"title":"Цена, руб.","closed":false,"content":{"min":900,"max":20000,"from":"","to":""}},{"title":"Основной материал","closed":false,"content":{"items":[{"href":"#","text":"Акрил","selected":false},{"href":"#","text":"Вискоза","selected":true},{"href":"#","text":"Лайкра","selected":false},{"href":"#","text":"Лен","selected":true},{"href":"#","text":"Клен","selected":false}],"limit":4}},{"title":"Размер","closed":false,"content":{"compact":true,"items":[{"href":"#","text":"38","selected":false},{"href":"#","text":"39","selected":false},{"href":"#","text":"40","selected":false},{"href":"#","text":"41","selected":false},{"href":"#","text":"42","selected":false},{"href":"#","text":"43","selected":false},{"href":"#","text":"44","selected":false},{"href":"#","text":"45","selected":false}]}}]};

/* Riot v2.0.12, @license MIT, (c) 2015 Muut Inc. + contributors */

;(function() {

  var riot = { version: 'v2.0.12', settings: {} }

  'use strict'

riot.observable = function(el) {

  el = el || {}

  var callbacks = {},
      _id = 0

  el.on = function(events, fn) {
    if (typeof fn == 'function') {
      fn._id = typeof fn._id == 'undefined' ? _id++ : fn._id

      events.replace(/\S+/g, function(name, pos) {
        (callbacks[name] = callbacks[name] || []).push(fn)
        fn.typed = pos > 0
      })
    }
    return el
  }

  el.off = function(events, fn) {
    if (events == '*') callbacks = {}
    else {
      events.replace(/\S+/g, function(name) {
        if (fn) {
          var arr = callbacks[name]
          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {
            if (cb._id == fn._id) { arr.splice(i, 1); i-- }
          }
        } else {
          callbacks[name] = []
        }
      })
    }
    return el
  }

  // only single event supported
  el.one = function(name, fn) {
    if (fn) fn.one = 1
    return el.on(name, fn)
  }

  el.trigger = function(name) {
    var args = [].slice.call(arguments, 1),
        fns = callbacks[name] || []

    for (var i = 0, fn; (fn = fns[i]); ++i) {
      if (!fn.busy) {
        fn.busy = 1
        fn.apply(el, fn.typed ? [name].concat(args) : args)
        if (fn.one) { fns.splice(i, 1); i-- }
         else if (fns[i] !== fn) { i-- } // Makes self-removal possible during iteration
        fn.busy = 0
      }
    }

    return el
  }

  return el

}
;(function(riot, evt) {

  // browsers only
  if (!this.top) return

  var loc = location,
      fns = riot.observable(),
      win = window,
      current

  function hash() {
    return loc.hash.slice(1)
  }

  function parser(path) {
    return path.split('/')
  }

  function emit(path) {
    if (path.type) path = hash()

    if (path != current) {
      fns.trigger.apply(null, ['H'].concat(parser(path)))
      current = path
    }
  }

  var r = riot.route = function(arg) {
    // string
    if (arg[0]) {
      loc.hash = arg
      emit(arg)

    // function
    } else {
      fns.on('H', arg)
    }
  }

  r.exec = function(fn) {
    fn.apply(null, parser(hash()))
  }

  r.parser = function(fn) {
    parser = fn
  }

  win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)

})(riot, 'hashchange')
/*

//// How it works?


Three ways:

1. Expressions: tmpl('{ value }', data).
   Returns the result of evaluated expression as a raw object.

2. Templates: tmpl('Hi { name } { surname }', data).
   Returns a string with evaluated expressions.

3. Filters: tmpl('{ show: !done, highlight: active }', data).
   Returns a space separated list of trueish keys (mainly
   used for setting html classes), e.g. "show highlight".


// Template examples

tmpl('{ title || "Untitled" }', data)
tmpl('Results are { results ? "ready" : "loading" }', data)
tmpl('Today is { new Date() }', data)
tmpl('{ message.length > 140 && "Message is too long" }', data)
tmpl('This item got { Math.round(rating) } stars', data)
tmpl('<h1>{ title }</h1>{ body }', data)


// Falsy expressions in templates

In templates (as opposed to single expressions) all falsy values
except zero (undefined/null/false) will default to empty string:

tmpl('{ undefined } - { false } - { null } - { 0 }', {})
// will return: " - - - 0"

*/


var brackets = (function(orig, s, b) {
  return function(x) {

    // make sure we use the current setting
    s = riot.settings.brackets || orig
    if (b != s) b = s.split(' ')

    // if regexp given, rewrite it with current brackets (only if differ from default)
    // else, get brackets
    return x && x.test
      ? s == orig
        ? x : RegExp(x.source
                      .replace(/\{/g, b[0].replace(/(?=.)/g, '\\'))
                      .replace(/\}/g, b[1].replace(/(?=.)/g, '\\')),
                    x.global ? 'g' : '')
      : b[x]

  }
})('{ }')


var tmpl = (function() {

  var cache = {},
      re_vars = /(['"\/]).*?[^\\]\1|\.\w*|\w*:|\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\b|function *\()|([a-z_$]\w*)/gi
              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]
              // find variable names:
              // 1. skip quoted strings and regexps: "a b", 'a b', 'a \'b\'', /a b/
              // 2. skip object properties: .name
              // 3. skip object literals: name:
              // 4. skip javascript keywords
              // 5. match var name

  // build a template (or get it from cache), render with data
  return function(str, data) {
    return str && (cache[str] = cache[str] || tmpl(str))(data)
  }


  // create a template instance

  function tmpl(s, p) {

    // default template string to {}
    s = (s || (brackets(0) + brackets(1)))

      // temporarily convert \{ and \} to a non-character
      .replace(brackets(/\\{/g), '\uFFF0')
      .replace(brackets(/\\}/g), '\uFFF1')

    // split string to expression and non-expresion parts
    p = split(s, brackets(/{[\s\S]*?}/g))

    return new Function('d', 'return ' + (

      // is it a single expression or a template? i.e. {x} or <b>{x}</b>
      !p[0] && !p[2] && !p[3]

        // if expression, evaluate it
        ? expr(p[1])

        // if template, evaluate all expressions in it
        : '[' + p.map(function(s, i) {

            // is it an expression or a string (every second part is an expression)
          return i % 2

              // evaluate the expressions
              ? expr(s, true)

              // process string parts of the template:
              : '"' + s

                  // preserve new lines
                  .replace(/\n/g, '\\n')

                  // escape quotes
                  .replace(/"/g, '\\"')

                + '"'

        }).join(',') + '].join("")'
      )

      // bring escaped { and } back
      .replace(/\uFFF0/g, brackets(0))
      .replace(/\uFFF1/g, brackets(1))

    + ';')

  }


  // parse { ... } expression

  function expr(s, n) {
    s = s

      // convert new lines to spaces
      .replace(/\n/g, ' ')

      // trim whitespace, curly brackets, strip comments
      .replace(brackets(/^[{ ]+|[ }]+$|\/\*.+?\*\//g), '')

    // is it an object literal? i.e. { key : value }
    return /^\s*[\w- "']+ *:/.test(s)

      // if object literal, return trueish keys
      // e.g.: { show: isOpen(), done: item.done } -> "show done"
      ? '[' + s.replace(/\W*([\w- ]+)\W*:([^,]+)/g, function(_, k, v) {

        return v.replace(/[^&|=!><]+/g, wrap) + '?"' + k.trim() + '":"",'

      }) + '].join(" ").trim()'

      // if js expression, evaluate as javascript
      : wrap(s, n)

  }


  // execute js w/o breaking on errors or undefined vars

  function wrap(s, nonull) {
    s = s.trim()
    return !s ? '' : '(function(v){try{v='

        // prefix vars (name => data.name)
        + (s.replace(re_vars, function(s, _, v) { return v ? '(d.'+v+'===undefined?window.'+v+':d.'+v+')' : s })

          // break the expression if its empty (resulting in undefined value)
          || 'x')

      + '}finally{return '

        // default to empty string for falsy values except zero
        + (nonull === true ? '!v&&v!==0?"":v' : 'v')

      + '}}).call(d)'
  }


  // a substitute for str.split(re) for IE8
  // because IE8 doesn't support capturing parenthesis in it

  function split(s, re) {
    var parts = [], last = 0
    s.replace(re, function(m, i) {
      // push matched expression and part before it
      parts.push(s.slice(last, i), m)
      last = i + m.length
    })
    // push the remaining part
    return parts.concat(s.slice(last))
  }

})()

// { key, i in items} -> { key, i, items }
function loopKeys(expr) {
  var ret = { val: expr },
      els = expr.split(/\s+in\s+/)

  if (els[1]) {
    ret.val = brackets(0) + els[1]
    els = els[0].slice(brackets(0).length).trim().split(/,\s*/)
    ret.key = els[0]
    ret.pos = els[1]
  }

  return ret
}

function mkitem(expr, key, val) {
  var item = {}
  item[expr.key] = key
  if (expr.pos) item[expr.pos] = val
  return item
}


/* Beware: heavy stuff */
function _each(dom, parent, expr) {

  remAttr(dom, 'each')

  var template = dom.outerHTML,
      prev = dom.previousSibling,
      root = dom.parentNode,
      rendered = [],
      tags = [],
      checksum

  expr = loopKeys(expr)

  function add(pos, item, tag) {
    rendered.splice(pos, 0, item)
    tags.splice(pos, 0, tag)
  }

  // clean template code
  parent.one('update', function() {
    root.removeChild(dom)

  }).one('premount', function() {
    if (root.stub) root = parent.root

  }).on('update', function() {

    var items = tmpl(expr.val, parent)
    if (!items) return

    // object loop. any changes cause full redraw
    if (!Array.isArray(items)) {
      var testsum = JSON.stringify(items)
      if (testsum == checksum) return
      checksum = testsum

      // clear old items
      each(tags, function(tag) { tag.unmount() })
      rendered = []
      tags = []

      items = Object.keys(items).map(function(key) {
        return mkitem(expr, key, items[key])
      })

    }

    // unmount redundant
    each(arrDiff(rendered, items), function(item) {
      var pos = rendered.indexOf(item),
          tag = tags[pos]

      if (tag) {
        tag.unmount()
        rendered.splice(pos, 1)
        tags.splice(pos, 1)
      }

    })

    // mount new / reorder
    var nodes = root.childNodes,
        prev_index = [].indexOf.call(nodes, prev)

    each(items, function(item, i) {

      // start index search from position based on the current i
      var pos = items.indexOf(item, i),
          oldPos = rendered.indexOf(item, i)

      // if not found, search backwards from current i position
      pos < 0 && (pos = items.lastIndexOf(item, i))
      oldPos < 0 && (oldPos = rendered.lastIndexOf(item, i))

      // mount new
      if (oldPos < 0) {
        if (!checksum && expr.key) item = mkitem(expr, item, pos)

        var tag = new Tag({ tmpl: template }, {
          before: nodes[prev_index + 1 + pos],
          parent: parent,
          root: root,
          item: item
        })

        tag.mount()

        return add(pos, item, tag)
      }

      // change pos value
      if (expr.pos && tags[oldPos][expr.pos] != pos) {
        tags[oldPos].one('update', function(item) {
          item[expr.pos] = pos
        })
        tags[oldPos].update()
      }

      // reorder
      if (pos != oldPos) {
        root.insertBefore(nodes[prev_index + oldPos + 1], nodes[prev_index + pos + 1])
        return add(pos, rendered.splice(oldPos, 1)[0], tags.splice(oldPos, 1)[0])
      }

    })

    rendered = items.slice()

  })

}


function parseNamedElements(root, parent, child_tags) {

  walk(root, function(dom) {
    if (dom.nodeType == 1) {

      // custom child tag
      var child = getTag(dom)

      if (child && !dom.getAttribute('each')) {
        var tag = new Tag(child, { root: dom, parent: parent })
        parent.tags[dom.getAttribute('name') || child.name] = tag
        child_tags.push(tag)
      }

      each(dom.attributes, function(attr) {
        if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom
      })
    }

  })

}

function parseExpressions(root, tag, expressions) {

  function addExpr(dom, val, extra) {
    if (val.indexOf(brackets(0)) >= 0) {
      var expr = { dom: dom, expr: val }
      expressions.push(extend(expr, extra))
    }
  }

  walk(root, function(dom) {
    var type = dom.nodeType

    // text node
    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)
    if (type != 1) return

    /* element */

    // loop
    var attr = dom.getAttribute('each')
    if (attr) { _each(dom, tag, attr); return false }

    // attribute expressions
    each(dom.attributes, function(attr) {
      var name = attr.name,
          bool = name.split('__')[1]

      addExpr(dom, attr.value, { attr: bool || name, bool: bool })
      if (bool) { remAttr(dom, name); return false }

    })

    // skip custom tags
    if (getTag(dom)) return false

  })

}

function Tag(impl, conf) {

  var self = riot.observable(this),
      opts = inherit(conf.opts) || {},
      dom = mkdom(impl.tmpl),
      parent = conf.parent,
      expressions = [],
      child_tags = [],
      root = conf.root,
      item = conf.item,
      fn = impl.fn,
      attr = {},
      loop_dom

  if (fn && root.riot) return
  root.riot = true

  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)

  // grab attributes
  each(root.attributes, function(el) {
    attr[el.name] = el.value
  })

  // options
  function updateOpts(rem_attr) {
    each(Object.keys(attr), function(name) {
      opts[name] = tmpl(attr[name], parent || self)
    })
  }

  this.update = function(data, init) {
    extend(self, data, item)
    updateOpts()
    self.trigger('update', item)
    update(expressions, self, item)
    self.trigger('updated')
  }

  this.mount = function() {

    updateOpts()

    // initialiation
    fn && fn.call(self, opts)

    toggle(true)

    // parse layout after init. fn may calculate args for nested custom tags
    parseExpressions(dom, self, expressions)

    self.update()

    // internal use only, fixes #403
    self.trigger('premount')

    if (fn) {
      while (dom.firstChild) root.appendChild(dom.firstChild)

    } else {
      loop_dom = dom.firstChild
      root.insertBefore(loop_dom, conf.before || null) // null needed for IE8
    }

    if (root.stub) self.root = root = parent.root
    self.trigger('mount')

  }


  this.unmount = function() {
    var el = fn ? root : loop_dom,
        p = el.parentNode

    if (p) {
      if (parent) p.removeChild(el)
      else while (root.firstChild) root.removeChild(root.firstChild)
      toggle()
      self.trigger('unmount')
      self.off('*')
      delete root.riot
    }

  }

  function toggle(is_mount) {

    // mount/unmount children
    each(child_tags, function(child) { child[is_mount ? 'mount' : 'unmount']() })

    // listen/unlisten parent (events flow one way from parent to children)
    if (parent) {
      var evt = is_mount ? 'on' : 'off'
      parent[evt]('update', self.update)[evt]('unmount', self.unmount)
    }
  }

  // named elements available for fn
  parseNamedElements(dom, this, child_tags)


}

function setEventHandler(name, handler, dom, tag, item) {

  dom[name] = function(e) {

    // cross browser event fix
    e = e || window.event
    e.which = e.which || e.charCode || e.keyCode
    e.target = e.target || e.srcElement
    e.currentTarget = dom
    e.item = item

    // prevent default behaviour (by default)
    if (handler.call(tag, e) !== true) {
      e.preventDefault && e.preventDefault()
      e.returnValue = false
    }

    var el = item ? tag.parent : tag
    el.update()

  }

}

// used by if- attribute
function insertTo(root, node, before) {
  if (root) {
    root.insertBefore(before, node)
    root.removeChild(node)
  }
}

// item = currently looped item
function update(expressions, tag, item) {

  each(expressions, function(expr) {

    var dom = expr.dom,
        attr_name = expr.attr,
        value = tmpl(expr.expr, tag),
        parent = expr.dom.parentNode

    if (value == null) value = ''

    // leave out riot- prefixes from strings inside textarea
    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')

    // no change
    if (expr.value === value) return
    expr.value = value

    // text node
    if (!attr_name) return dom.nodeValue = value

    // remove original attribute
    remAttr(dom, attr_name)

    // event handler
    if (typeof value == 'function') {
      setEventHandler(attr_name, value, dom, tag, item)

    // if- conditional
    } else if (attr_name == 'if') {
      var stub = expr.stub

      // add to DOM
      if (value) {
        stub && insertTo(stub.parentNode, stub, dom)

      // remove from DOM
      } else {
        stub = expr.stub = stub || document.createTextNode('')
        insertTo(dom.parentNode, dom, stub)
      }

    // show / hide
    } else if (/^(show|hide)$/.test(attr_name)) {
      if (attr_name == 'hide') value = !value
      dom.style.display = value ? '' : 'none'

    // field value
    } else if (attr_name == 'value') {
      dom.value = value

    // <img src="{ expr }">
    } else if (attr_name.slice(0, 5) == 'riot-') {
      attr_name = attr_name.slice(5)
      value ? dom.setAttribute(attr_name, value) : remAttr(dom, attr_name)

    } else {
      if (expr.bool) {
        dom[attr_name] = value
        if (!value) return
        value = attr_name
      }

      if (typeof value != 'object') dom.setAttribute(attr_name, value)

    }

  })

}
function each(els, fn) {
  for (var i = 0, len = (els || []).length, el; i < len; i++) {
    el = els[i]
    // return false -> reomve current item during loop
    if (el != null && fn(el, i) === false) i--
  }
  return els
}

function remAttr(dom, name) {
  dom.removeAttribute(name)
}

// max 2 from objects allowed
function extend(obj, from, from2) {
  from && each(Object.keys(from), function(key) {
    obj[key] = from[key]
  })
  return from2 ? extend(obj, from2) : obj
}

function mkdom(template) {
  var tag_name = template.trim().slice(1, 3).toLowerCase(),
      root_tag = /td|th/.test(tag_name) ? 'tr' : tag_name == 'tr' ? 'tbody' : 'div',
      el = document.createElement(root_tag)

  el.stub = true
  el.innerHTML = template
  return el
}

function walk(dom, fn) {
  if (dom) {
    if (fn(dom) === false) walk(dom.nextSibling, fn)
    else {
      dom = dom.firstChild

      while (dom) {
        walk(dom, fn)
        dom = dom.nextSibling
      }
    }
  }
}

function arrDiff(arr1, arr2) {
  return arr1.filter(function(el) {
    return arr2.indexOf(el) < 0
  })
}

function inherit(parent) {
  function Child() {}
  Child.prototype = parent
  return new Child()
}



/*
 Virtual dom is an array of custom tags on the document.
 Updates and unmounts propagate downwards from parent to children.
*/

var virtual_dom = [],
    tag_impl = {}


function getTag(dom) {
  return tag_impl[dom.tagName.toLowerCase()]
}

function injectStyle(css) {
  var node = document.createElement('style')
  node.innerHTML = css
  document.head.appendChild(node)
}

function mountTo(root, tagName, opts) {
  var tag = tag_impl[tagName]

  if (tag && root) tag = new Tag(tag, { root: root, opts: opts })

  if (tag && tag.mount) {
    tag.mount()
    virtual_dom.push(tag)
    return tag.on('unmount', function() {
      virtual_dom.splice(virtual_dom.indexOf(tag), 1)
    })
  }

}

riot.tag = function(name, html, css, fn) {
  if (typeof css == 'function') fn = css
  else if (css) injectStyle(css)
  tag_impl[name] = { name: name, tmpl: html, fn: fn }
}

riot.mount = function(selector, tagName, opts) {
  if (selector == '*') selector = Object.keys(tag_impl).join(', ')
  if (typeof tagName == 'object') { opts = tagName; tagName = 0 }

  var tags = []

  function push(root) {
    var name = tagName || root.tagName.toLowerCase(),
        tag = mountTo(root, name, opts)

    if (tag) tags.push(tag)
  }

  // DOM node
  if (selector.tagName) {
    push(selector)
    return tags[0]

  // selector
  } else {
    each(document.querySelectorAll(selector), push)
    return tags
  }

}

// update everything
riot.update = function() {
  return each(virtual_dom, function(tag) {
    tag.update()
  })
}

// @deprecated
riot.mountTo = riot.mount


  
  // share methods for other riot parts, e.g. compiler
  riot.util = { brackets: brackets, tmpl: tmpl }

  // support CommonJS
  if (typeof exports === 'object')
    module.exports = riot

  // support AMD
  else if (typeof define === 'function' && define.amd)
    define(function() { return riot })

  // support browser
  else
    this.riot = riot

})();

riot.tag('x-banner', '<div class="banner{opts.grid ? \' banner_grid\' : \'\'}"> <a href="{opts.href}" class="banner__link">{opts.text}</a> </div>', function(opts) {

});

riot.tag('x-breadcrumbs', '<div class="breadcrumbs"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-breadcrumbs-item', '<div class="breadcrumbs__item"> <a href="{opts.href}" class="breadcrumbs__link">{opts.text}</a> </div>', function(opts) {

});

riot.tag('x-categories', '<div class="categories"> <div class="categories__title">Категории</div> <div each="{opts.items}" class="categories__item categories__item_level_{level}"> <a href="{href}" class="categories__link{current ? \' is-current\' : \'\'}">{text}</a> </div> </div>', function(opts) {

});

riot.tag('x-checkbox-list', '<div class="checkbox-list{opts.compact ? \' is-compact\' : \'\'}"> <div class="checkbox-list__list"> <div class="checkbox-list__item" each="{items}"> <a href="{href}" class="checkbox-list__link{selected ? \' is-selected\' : \'\'}"> {text} </a> </div> </div> <div class="checkbox-list__more" if="{counter > 0}">{"Еще " + counter + "…"}</div> </div>', function(opts) {

  this.shown   = this.opts.limit ? this.opts.limit : this.opts.items.length;
  this.items   = this.opts.items.slice(0, this.shown);
  this.counter = this.opts.items.length - this.opts.limit;

});

riot.tag('x-content', '<div class="content"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-facet', '<div class="facet{opts.closed ? \' is-closed\' : \'\'}"> <div class="facet__title">{opts.title}</div> <div class="facet__content"> <inner-html></inner-html> </div> </div>', function(opts) {

});

riot.tag('x-facets', '<div class="facets"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-footer', '<div class="footer">© 2013-2015 Общество Фей</div>', function(opts) {

});

riot.tag('x-header', '<div class="header"> <div class="header__subtitle">интернет-магазин одежды</div> <div class="header__actions"> <div class="header__action header__action_signin"> <a href="#" class="header__link">Войти</a> </div> <div class="header__action header__action_signup"> <a href="#" class="header__link">Зарегистрироваться</a> </div> <div class="header__action header__action_basket"> <a href="#" class="header__link">Корзина</a> </div> </div> <div class="header__title">Золушка</div> <div class="header__search"> <inner-html></inner-html> </div> </div>', function(opts) {

});

riot.tag('inner-html', '', function(opts) {
  var p = this.parent.root
  while (p.firstChild) this.root.appendChild(p.firstChild)

});

riot.tag('x-list-item', '<div class="list-item"> <a href="{opts.href}"><img riot-src="{opts.image}" class="list-item__image"></a> <div class="list-item__meta"> <div class="list-item__price">{formattedPrice}</div> <div class="list-item__title"><a href="{opts.href}">{opts.title}</a></div> <div class="list-item__description"> {opts.description} </div> </div> </div>', function(opts) {

  this.formattedPrice = this.opts.price.toLocaleString("ru-RU", {style: "currency", currency: "RUB", minimumFractionDigits: 0});

});

riot.tag('x-listing', '<div class="listing"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-header', '<div class="listing__header"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-breadcrumbs', '<div class="listing__breadcrumbs"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-title', '<h1 class="listing__title">{opts.title}</h1>', function(opts) {

});

riot.tag('x-listing-sorting', '<div class="listing__sorting"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-view-mode', '<div class="listing__view-mode"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-content', '<div class="listing__content"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-listing-items', '<div class="listing__items{opts.advanced ? \' listing__items_advanced\' : \'\'}"> <inner-html></inner-html> </div>', function(opts) {

  console.log(this.opts.advanced)

});

riot.tag('x-listing-nav', '<div class="listing__nav"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-menu', '<div class="menu"> <div class="menu__content"> <div each="{opts.items}" class="menu__item"> <a href="{href}" class="menu__link{current ? \' is-current\' : \'\'}">{text}</a> </div> </div> </div>', function(opts) {

});

riot.tag('x-page', '<div class="page"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-preview-item', '<div class="preview-item"> <a href="{opts.href}" class="preview-item__link"> <img riot-src="{opts.image}" class="preview-item__image"> <div class="preview-item__meta"> <div class="preview-item__title">{opts.title}</div> <div class="preview-item__price">{formattedPrice}</div> </div> </a> </div>', function(opts) {

  this.formattedPrice = this.opts.price.toLocaleString("ru-RU", {style: "currency", currency: "RUB", minimumFractionDigits: 0});

});

riot.tag('x-price', '<div class="price"> <div class="price__range"> <div class="price__group price__group_from"> <label class="price__title">От:</label> <input type="text" class="price__field" placeholder="{opts.min}" value="{opts.from}"> </div> <div class="price__group price__group_to"> <label class="price__title">До:</label> <input type="text" class="price__field" placeholder="{opts.max}" value="{opts.to}"> </div> </div> <div class="price__show">Показать</div> </div>', function(opts) {

});

riot.tag('x-search', '<form action=" {opts.action}" class="search"> <input type="search" placeholder="платье бальное" class="search__query" value=" {opts.value}"> <input type="submit" value="Найти" class="search__submit"> </form>', function(opts) {

  var parent = this.parent;

});

riot.tag('x-sorting', '<div class="sorting"> <div class="sorting__title">Сортировать:</div> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-sorting-item', '<div class="sorting__item"> <a href="{opts.href}" class="sorting__link{opts.current ? \' is-current\' : \'\'}">{opts.text}</a> </div>', function(opts) {

});

riot.tag('x-view-mode', '<div class="view-mode"> <inner-html></inner-html> </div>', function(opts) {

});

riot.tag('x-view-mode-item', '<div class="view-mode__item"> <a href="{opts.href}" class="view-mode__link{opts.current ? \' is-current\' : \'\'}">{opts.text}</a> </div>', function(opts) {

});
